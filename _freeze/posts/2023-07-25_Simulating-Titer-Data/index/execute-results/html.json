{
  "hash": "530af011ffbdfec9998939457e24cbd6",
  "result": {
    "markdown": "---\ntitle: \"Simulating Titer Data\"\nauthor: \"Zane Billings\"\ndate: \"2023-07-25\"\ndescription: |\n  So I work with a lot of immunological titer data, particularly HAI titers\n  for flu. And I've recently needed to work out how to do some simulations. So\n  this post will cover the generative model I've developed and show some\n  examples, while hopefully explaining each step in a way. Mostly so my adviser\n  can tell me what he thinks I did wrong.\nlicense: \"CC BY-SA\"\ndraft: false\n---\n\n\n![A sample histogram showing what exciting results are to come!](thumbnail.png)\n\nSo this will probably be a shorter post, but it will hopefully be the first\nin a series of posts about some immunological data problems I'm working on\nright now. In this post, I'll give a brief background on immunological titer\ndata, a short explanation of why I care, and then I'll walk through the\ngenerative model I've adopted for simulating titer data. I plan to explain\nthe steps of my model and show how each part works both in math and in `R`\ncode. Of course I will have to make some simplifying assumptions, but I'll\ntry to explain what those are and what any alternatives might be.\n\n# Background\n\nI'm currently interested in antigenic distance, and particularly how it\nrelates to the immunogenicity of the flu vaccine. However, there are some\nunique challenges in trying to quantify the immunogenicity of a given\nseasonal vaccine because of how often flu mutates. In the process of\ndeveloping better methods for this task, we need to validate our method in\nsituations where we know what the expected answer should be, and then we\ncan compare the performance in simulated settings to the real-world results\nwe get.\n\nSo, I need to be able to simulate titer data. Specifically, I'm interested\nin HAI titer data, but there's no reason this couldn't be adapted to work\non other measurements. HAI titers are a bit peculiar, because they start at\n10 and then each successive measurement doubles, i.e., 10, 20, 40, 80, etc.\nA titer of 10 is the limit of detection (LoD) of the assay, and any value below\n10 will be *censored*! That is, we know the value is below 10, but not quite\nwhere. We can further say that we know the value should be 0 or greater, but\nwe will work on the log scale where this constraint is enforced naturally.\n\nSo whatever generative model we adapt needs to take on only these values,\nand needs to have a censoring mechanism. In reality, we know that a given\nHAI measurement is really *interval-censored*: if your HAI measurement is\n40, what we really know is that your true HAI titer is in the range $[40, 80]$.\nSo, when we generate someone's titer, it needs to come from an **underlying\ndata generating process that can generate any positive titer value,** but our\nobservations are flawed. (I think we can then also incorporate the LoD issue into this\ninterval censoring framework but until I can figure that out explicitly they\nremain conceptually different in my brain.)\n\nAnyways, the last thing I'll mention before talking about my proposed data\ngenerating process is the scale of interest. I've already mentioning working\non the log scale, but that isn't 100% accurate. So for the rest of this post\n(and potentially series), I'll refer to the **natural scale** when I'm talking\nabout measures of titers like I discussed before, i.e. 10, 20, 40, and so on.\nWhen I refer to the **log scale**, I specifically mean that we'll apply the\ntransformation\n$$g(x) = \\log_2 \\left(\\frac{x}{5}\\right)$$\nto the natural scale variables. Since values at the LoD are typically recoded\nas 5, and the numbers on the natural scale double consecutively, the values\non this transformed scale will start at 0 and increase by 1, e.g. 0, 1, 2, 3, \nwould correspond to the natural scale titers 5, 10, 20, 40.\n\nOK, with that background out of the way I'll talk about simulating titer data.\n\n# Simulation methods\n\nFirst, I'll attempt to simulate raw titer data, without including antigenic\ndistance in the simulation. Of course since I care about antigenic distance,\neventually that will need to be part of the simulation and that will probably\nbe the next blog post. So we'll first develop a model to simulate observations\nof a single titer measurement, and then adapt that in the future.\n\nThe outcome we want this simulation to produce\nis a semi-realistic distribution of titer values with support on the observed\nmeasurement space. We adopt the following model, where $y_i$ is the $i$th\nindividual's measured titer.\n\n$$\n\\begin{align*}\n\\log_2 y_i &\\sim \\mathcal{N}(\\mu, \\sigma^2) \\\\\ny_i^* &= \\begin{cases}\n5 & \\log_2 y_i < 1 \\\\\n5 \\cdot \\lfloor 2 ^ {y_i} \\rfloor & \\log_2 y_i \\geq 1\n\\end{cases}\n\\end{align*}\n$$\nWe adopt the transformation\n$$\ng^{-1}(y) = 5 \\cdot 2^{y_i},\n$$\nas previously stated, because the physical limit of detection (LoD) of the HAI assay is\n$$\n10 = 5 \\cdot 2 ^ 1\n$$\nand values below this threshold are typically recorded as $5$. So we know\nthose values are below the LoD, but not what the values are. The distributional\nparameters $\\mu$, the mean, and $\\sigma^2$, the variance, are unknown to us\npractically and must be estimated from the data.\n\n**Note.** I chose a normal distribution for the underlying continuous titer\nvalues because it is the easiest distribution to work with. In this framework,\n$y_i$ has a (scaled) log-normal distribution. And honestly, things just tend\nto work out find with the normal distribution. An alternative distribution\ncould be used here, such as the gamma distribution, for a different shape\nof titer distributions.\n\nWriting `R` code to sample from this model is simple.\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_titer_sim <- function(N = 1e4, seed = 370, mean = 3, sd = 1) {\n\tset.seed(seed)\n\tsim <-\n\t\ttibble::tibble(\n\t\t\t# Assume log(titer) is drawn from a normal distribution\n\t\t\traw_log_titer = rnorm(N, mean, sd),\n\t\t\t# If we observe a titer with log(titer) < 1 (LOD), mark it as 0\n\t\t\ttrunc_log_titer = ifelse(raw_log_titer >= 1, raw_log_titer, 0),\n\t\t\t# The assay is dilution based, so we only observe the floor of each\n\t\t\t# value.\n\t\t\trounded_titer = floor(trunc_log_titer),\n\t\t\t# Now final observed titer is equal to this transformation.\n\t\t\tsim_titer = 5 * 2 ^ rounded_titer\n\t\t) |>\n\t\tdplyr::arrange(raw_log_titer)\n}\n\nout <- one_titer_sim(1000, mean = 3, sd = 1)\n#plot(out$raw_log_titer, out$trunc_log_titer)\n#points(out$raw_log_titer, out$rounded_titer, col = \"blue\")\nbarplot(table(out$sim_titer))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nIn the above plot, you can see the result of 1000 simulations, where $\\mu = 3$\nand $\\sigma = \\sigma^2 = 1$. Notably, while the mean\nwas specified as $3$ (an observed titer of $40$), the mode of the distribution\nis at $20$ instead.\n\nWe can also notice that the observed mean is biased, estimated at\n$2.55$ on the scale of $y_i$ in\nthe above model ($29.28$\non the natural scale). A [stackexchange post](https://math.stackexchange.com/questions/3662314/statistics-of-a-gaussian-random-variable-with-the-floor-function-transformation) suggested that as long as $\\sigma^2$ is\n\"not small\" (suggested as $\\sigma^2 \\geq 1$ [here](https://mathematica.stackexchange.com/questions/278040/finding-the-mean-and-variance-of-a-distribution/278164#278164)), $\\mu \\approx \\bar{x} + \\frac{1}{2}$ is a\ngood approximation to the mean (on the log\nscale), which is close to what we observed.\n\n# Conclusion\n\nSo I think that was a pretty simple probability model, but I think the hard\npart will be dealing with the unique challenges that censoring entails. In the\nnext step, I'll incorporate antigenic distance into the generative model by\nreplacing the mean with a linear function. After that, we can dive into methods\nof estimation, using Stan models. But overall I'm pretty happy with this\ngenerative model, though I always welcome thoughts and comments on how it can\nbe improved.\n\n## Details {.appendix}\n\nLast updated at 2023-07-25 22:28:08.82951.\n\n[source code](https://github.com/wzbillings/zlog/tree/master/_posts/posts/2023-07-25_Simulating-Titer-Data/index.Rmd)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19044)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.5.0       cli_3.4.1         knitr_1.40        rlang_1.0.6      \n [5] xfun_0.34         stringi_1.7.8     renv_0.16.0       generics_0.1.3   \n [9] jsonlite_1.8.3    glue_1.6.2        htmltools_0.5.3   fansi_1.0.3      \n[13] rmarkdown_2.17    evaluate_0.17     tibble_3.1.8      fastmap_1.1.0    \n[17] yaml_2.3.6        lifecycle_1.0.3   stringr_1.4.1     compiler_4.3.0   \n[21] dplyr_1.0.10      htmlwidgets_1.5.4 pkgconfig_2.0.3   digest_0.6.30    \n[25] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.2        pillar_1.8.1     \n[29] magrittr_2.0.3    tools_4.3.0      \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}