{
  "hash": "af0203af9fd130ffcfc1123b5a5f063c",
  "result": {
    "markdown": "---\ntitle: \"Simulating Titer Data with Distance as a Covariate\"\nauthor: \"Zane Billings\"\ndate: \"2023-08-10\"\ndescription: |\n  In the second part of the HAI data manifesto, we'll discuss how to incorporate\n  a single covariate into the data generating process.\nlicense: \"CC BY-SA\"\ndraft: false\n---\n\n\n\n\nIn my [previous blog post](https://wzbillings.com/posts/2023-07-25_simulating-titer-data/)\nI talked about how to simulate a common type of immunological titer data, which\nis subject to both interval censoring and a lower limit of detection. In that\nblog post, we describing the data generating process for the observed values,\nand our simulation depended on the prespecification of the mean and variance of\nthe distribution. In this blog post, we'll discuss how we can extend the data\ngenerating process to include other variables. In particular, my research\nfocuses on how *antigenic distance* can affect these titer values, but the\nway I'll extend these simulations is very general.\n\nFirst let's review the data-generating process -- this is actually probably\nbetter written than my original post on this, because I've been thinking\nabout these issues a lot and trying to improve my descriptions and notations.\n\n## Data-generating process without covariates\n\nIf we recall our DGP from the previous post,\n$$\n\\begin{aligned}\nz_i^* &\\sim \\mathcal{N}\\left(\\mu, \\sigma^2\\right) \\\\\nz_i &= \\max\\left\\{0, \\left\\lfloor z_i^* \\right\\rfloor \\right\\} \\\\\ny_i &= g(z_i) = 5 \\cdot 2 ^{z_i}\n\\end{aligned}\n$$\nThis data generation process is composed of the following parts:\n\n* The **log-scale latent titer**, $z_i^*$, which is a real-valued random\nvariable;\n* The **log-scale censored titer**, $z_i$, which is a nonnegative integer-\nvalued random variable. This reflects the limit of detection -- our transformation\nfunction $g(\\cdot)$ which takes us from the natural scale to the log scale\nensures that the limit of detection is represented as $0$ on the log scale. So\nif $z_i$ is below the log-scale LoD, it gets rounded up to $0$. Otherwise, we\ntake the floor of the underlying titer to represent interval-censoring in\nour measurements.\n* The **natural-scale observed titer**, $y_i$, is a nonnegative integer on the\nnatural scale and so takes values in the set $\\{5, 10, 20, 40, \\ldots \\}$.\nThis value has been censored and transformed back to the natural scale.\n\nThis data generating process assumes that the latent titers follow a log-normal\ndistribution. Another plausible model would be a gamma distribution, which\nis somewhat more annoying to deal with, so we'll deal with that in a future\npost.\n\nNow, I promised we would incorporate some covariates, so that's what we'll\ndo next.\n\n## Perfectly known covariates and linear models\n\nThere are a lot of different ways to incorporate covariates into this type\nof model, but the most common way by far is to make the mean titer value\ndependent on the value of some covariate, i.e., we would add the line\n$$\\mu_i = f(x_i) $$\nto the DGP above. Choosing the correct function here is a very complex problem\nwhich relies on \"good-enough\" approximations in the real world. One incredibly\nsimple, but also very useful, function is the simple linear regression model.\nLinear models cover a wide range of patterns, but in the simple linear model,\nwe assume that $f(x) = \\beta_0 + \\beta_1 x$, which is a linear function of $x$.\nFor my specific example of incorporating antigenic distance, $d$ into the\ndata generating process, we'll use this simple linear regression model.\n\nAt the risk of repeating a lot of text, our data generating process when the\nmean of the titer depends on the antigenic distance in a linear relationship is\nas follows.\n\n$$\n\\begin{aligned}\nz_i^* &\\sim \\mathcal{N}\\left(\\mu_i, \\sigma^2\\right) \\\\\n\\mu_i &= \\beta_0 + \\beta_1 \\cdot d_i \\\\\nz_i &= \\max\\left\\{0, \\left\\lfloor z_i^* \\right\\rfloor \\right\\} \\\\\ny_i &= g(z_i) = 5 \\cdot 2 ^{z_i}\n\\end{aligned}\n$$\n\nWe would expect $\\beta_0 > 0$ and $\\beta_1 < 0$ here. The parameter $\\beta_0$\nwould correspond to the homologous immune response -- we're testing the HAI\ntiter against the exact same strain a person has been exposed to. The parameter\n$\\beta_1$ then represents the expected decrease in the immune response as a\ntest strain becomes further away from the exposure strain. If we normalize our\ndistances to fall in $[0, 1]$, where $0$ is the homologous strain and $1$ is the\nmaximally different strain (although still not completely different, depending\non the sample), we would also note that\n$$E[y \\mid x = 1] - E[y \\mid x = 0] = \\mu(1) - \\mu(0) = \\beta_1,$$\nso we can interpret $\\beta_1$ as the difference in the mean response between\nthe maximally distant strain and the homologous strain. If the maximally\ndistant strain should represent a completely novel strain for which there should\nbe no immune response, we could enforce the constraint\n$$\\mu_i(1) = 0 \\implies \\beta_0 + \\beta_1 = 0,$$\nwhich is linear and could be incorporated into a solution using a constrained\nmaximum likelihood estimation framework.\n\nThe data is easy to simulate, similar to the previous example. For a test\nexample, we assume that we can choose which antigenic distances to measure, and\nat each antigenic distance, we obtain some number of independent titer values\n(we could relax the independence assumption here by using a more complex model,\nbut we choose not to deal with that right now).\n\nFor this example, we'll set our distances for each individual to be\n$d_i = \\{0, 0.1, 0.2, \\ldots, 1.0\\}$, and we'll assume we have $1000$\nindividuals. We collect their titers at each distance. For our simulation\nparameters, we'll set $\\beta_0 = 4$, $\\beta_1 = -3$, and $\\sigma^2 = 2$.\n\nWe start with the same simulation function we used previously.\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_titer_sim <- function(N = 1e4, seed = 370, mean = 3, sd = 1) {\n\tset.seed(seed)\n\tsim <-\n\t\ttibble::tibble(\n\t\t\t# Assume log(titer) is drawn from a normal distribution\n\t\t\traw_log_titer = rnorm(N, mean, sd),\n\t\t\t# If we observe a titer with log(titer) < 1 (LOD), mark it as 0\n\t\t\ttrunc_log_titer = ifelse(raw_log_titer >= 1, raw_log_titer, 0),\n\t\t\t# The assay is dilution based, so we only observe the floor of each\n\t\t\t# value.\n\t\t\trounded_titer = floor(trunc_log_titer),\n\t\t\t# Now final observed titer is equal to this transformation.\n\t\t\tsim_titer = 5 * 2 ^ rounded_titer\n\t\t) |>\n\t\tdplyr::arrange(raw_log_titer)\n}\n```\n:::\n\n\nThen, we calculate the value of $\\mu_i$ at each value of $d_i$, and draw\n1000 observations at each $\\mu$ value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_dist_sim <-\n\ttibble::tibble(\n\t\td = seq(0, 1, 0.1),\n\t\tmu = 4 - 3 * d\n\t) |>\n\tdplyr::mutate(\n\t\tsim = purrr::map(mu, \\(x) one_titer_sim(1000, mean = x, sd = 2))\n\t) |>\n\ttidyr::unnest(sim)\n\nplt <-\n\tex_dist_sim |>\n\tdplyr::mutate(\n\t\tsim_titer = factor(sim_titer),\n\t\tmu = factor(mu) |> forcats::fct_inorder(),\n\t\tdistance = factor(d) |> forcats::fct_inorder()\n\t) |>\n\tggplot() +\n\taes(x = sim_titer) +\n\tgeom_bar(col = \"black\", fill = \"gray\") +\n\tfacet_wrap(~distance, labeller = \"label_both\") +\n\tlabs(\n\t\tx = \"Observed titer\",\n\t\ty = \"Count\"\n\t) +\n\ttheme(axis.text.x = element_text(angle = 45)) +\n\tcoord_cartesian(ylim = c(0, 700))\nfn <- here::here(\"posts\", \"2023-08-10_Titer-w-Distance\", \"thumbnail.png\")\nggsave(\n\tfilename = fn,\n\tplot = plt,\n\twidth = 13,\n\theight = 8\n)\nknitr::include_graphics(fn)\n```\n\n::: {.cell-output-display}\n![](thumbnail.png)\n:::\n:::\n\n\nIf we simulate a more extreme example, say where $|\\beta_1| > \\beta_0$, we\ncan generate titers which decay rapidly towards the limit of detection. In the\nnext simulation, we left all simulation parameters the same except we set\n$\\beta_1 = -6$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_dist_sim <-\n\ttibble::tibble(\n\t\td = seq(0, 1, 0.1),\n\t\tmu = 4 - 6 * d\n\t) |>\n\tdplyr::mutate(\n\t\tsim = purrr::map(mu, \\(x) one_titer_sim(1000, mean = x, sd = 2))\n\t) |>\n\ttidyr::unnest(sim)\n\nplt <-\n\tex_dist_sim |>\n\tdplyr::mutate(\n\t\tsim_titer = factor(sim_titer),\n\t\tmu = factor(mu) |> forcats::fct_inorder(),\n\t\tdistance = factor(d) |> forcats::fct_inorder()\n\t) |>\n\tggplot() +\n\taes(x = sim_titer) +\n\tgeom_bar(col = \"black\", fill = \"gray\") +\n\tfacet_wrap(~distance, labeller = \"label_both\") +\n\tlabs(\n\t\tx = \"Observed titer\",\n\t\ty = \"Count\"\n\t) +\n\ttheme(axis.text.x = element_text(angle = 45)) +\n\tcoord_cartesian(ylim = c(0, 700))\nfn <- here::here(\"posts\", \"2023-08-10_Titer-w-Distance\", \"p2.png\")\nggsave(\n\tfilename = fn,\n\tplot = plt,\n\twidth = 13,\n\theight = 8\n)\nknitr::include_graphics(fn)\n```\n\n::: {.cell-output-display}\n![](p2.png)\n:::\n:::\n\n\n## Conclusions\n\nIn this relatively short post, I showed a quick example of including distance\nas a covariate in a linear model for titers. There are a couple more things we\nneed to do for an HAI manifesto though, and we're currently working on them\nright now! Not sure if they will be blog posts or part of something else though.\nImportantly, we might be interested in\n\n* Modeling the post-vaccination titer as a function of distance and\npre-vaccination titer;\n* Covariates with their own parametric models, such as for measurement error;\n* On the idea of measurement error, accounting for measurement error in the\noutcome variable along with censoring; and most importantly\n* How do we account for all of those issues in a statistical model, and\nhopefully recover the parameters of the known DGP?\n\n## Details {.appendix}\n\nLast updated at 2023-11-06 10:54:38.522226.\n\n[source code](https://github.com/wzbillings/zlog/tree/master/_posts/posts/2023-08-10_Titer-w-Distance/index.Rmd)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] ggplot2_3.4.4\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.1      jsonlite_1.8.7    dplyr_1.0.10      compiler_4.3.1   \n [5] renv_1.0.3        tidyselect_1.2.0  stringr_1.4.1     tidyr_1.2.1      \n [9] scales_1.2.1      yaml_2.3.6        fastmap_1.1.0     here_1.0.1       \n[13] R6_2.5.1          labeling_0.4.2    generics_0.1.3    knitr_1.40       \n[17] forcats_1.0.0     htmlwidgets_1.5.4 tibble_3.1.8      rprojroot_2.0.3  \n[21] munsell_0.5.0     pillar_1.8.1      rlang_1.1.1       utf8_1.2.2       \n[25] stringi_1.7.8     xfun_0.34         cli_3.6.1         withr_2.5.0      \n[29] magrittr_2.0.3    digest_0.6.33     grid_4.3.1        lifecycle_1.0.3  \n[33] vctrs_0.5.0       hgp_0.0.1         evaluate_0.23     glue_1.6.2       \n[37] farver_2.1.1      fansi_1.0.3       colorspace_2.0-3  rmarkdown_2.17   \n[41] purrr_0.3.5       tools_4.3.1       pkgconfig_2.0.3   ellipsis_0.3.2   \n[45] htmltools_0.5.3  \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}